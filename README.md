# Simple messenger

## О чем проект

Проект представляет собой **backend** для мессенджера.
Пользователи могут регистрироваться, отправлять друг другу сообщения, добавлять в друзья.

## Стек технологий

- Spring Web
- Spring WebSockets
- Spring Data Jpa
- Spring Security
- Spring Validation
- Spring Mail
- Spring Boot
- Postgresql
- Swagger
- Liquibase
- Mapstruct
- Maven
- Docker

## Доп задания

Были выполнены все доп задания

## Конфигурация

Для корректной работы приложения необходимо передать **environment** параметры.
Для настройки **Spring Mail** используются следующие параметры:

- `MAIL_HOST`
- `MAIL_PORT`
- `MAIL_USERNAME`
- `MAIL_PASSWORD`
- `STARTTLS_ENABLE`

Также в проекте есть бин `EmailService`, который нуждается в настройке.
Его параметры:

- `EMAIL_SERVICE_DOMAIN` - Домен текущего сервера. **Можно не указывать**.
  По умолчанию равняется `localhost`.


- `EMAIL_SERVICE_PORT` - Порт текущего сервера. **Можно не указывать**.
  По умолчанию равняется `8080`


- `EMAIL_SERVICE_USE_HTTPS` - Булево значение, отвечает за использование протокола **https**.
  **Можно не указывать**. По умолчанию равняется **false**.

Для настройки бина `JwtService` необходимо указать параметр
`JWT_SECRET_KEY` - Ключ для подписи токенов. Можно не указывать,
тогда будет использоваться ключ по умолчанию.

**В целях тестирования можно оставить значения по умолчанию.**

## Запуск

Запустить приложение можно командами `mvn clean package`, затем `docker compose up`,
добавив **environment** переменные
в
сервисе **app** файла `compose.yaml`.

## Эндпойнты

Эндпойнты разбиты по трем категориям:

1. **auth** - Для регистрации, авторизации и прочих операций, связанных с безопасностью.
2. **user** - Для операций, связанных с пользователями.
3. **friend** - Для операций, связанных со списками друзей.

## Примеры всех возможных эндпойнтов

---

- `POST /auth/sign_up` - регистрация нового пользователя.

В тело подается **json** вида:

```json
{
  "username": "user",
  "password": "passwd",
  "email": "user@gmail.com",
  "name": "alex",
  "surname": "johnson"
}
```

В ответе передается header `Authorization` с jwt токеном.

---

- `POST /auth/login` - вход в аккаунт.

В тело подается **json** вида:

```json
{
  "username": "user",
  "password": "passwd"
}
```

В ответе передается header `Authorization` с jwt токеном.

---

- `POST /auth/logout` - выход из аккаунта.

---

- `PUT /user/edit` - редактировать профиль текущего пользователя.

В тело подается **json** вида:

```json
{
  "name": "alex",
  "surname": "johnson",
  "email": "user@gmail.com"
}
```

Если какой-то из параметров не был передан, это значение не изменится в профиле пользователя.
Если email был изменен, на почту будет выслано письмо для подтверждения нового email.

---

- `PUT /user/edit_creds` - редактировать данные для логина у текущего пользователя.

В тело подается **json** вида:

```json
{
  "username": "user",
  "password": "passwd"
}
```

При запросе на этот эндпойнт будет выполнен разлогин.

---

- `POST /user/send_email` - отправить письмо для подтверждения почты.

---

- `POST /user/disable` - отключить аккаунт пользователя.
  На почту пользователя отправляется ссылка для восстановления аккаунта,
  действующая в течение месяца.

---

- `GET /user/verify_email/{token}` - подтвердить email.

---

- `GET /user/enable/{token}` - восстановить аккаунт пользователя.

---

- `POST /friends/add/{username}` - добавить пользователя в список друзей текущего пользователя.

---

- `GET /friends/get` - получить список друзей текущего пользователя.

---

- `GET /friends/get/{username}` - получить список друзей выбранного пользователя.

---

- `DELETE /friends/remove/{username}` - удалить выбранного пользователя
  из списка друзей текущего пользователя.

---

- `POST /friends/hide` - скрыть список друзей текущего пользователя.
  Другие пользователи не смогут воспользоваться эндпойнтом `GET /friends/get/{username}`
  для получения его списка друзей.

---

- `POST /friends/open` - открыть список друзей текущего пользователя.

---

- `GET /swagger-ui/index.html` - swagger ui

---

Обмен сообщениями реализован через **WebSockets** по пути `/chat/{username}`.